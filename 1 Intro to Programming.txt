(very imp. for c) - are marked with *

logic -> represent

Intro to programming
	- methods of representing logic: pesudocode / flowchart
/programming lang. *

	- Higher Level, Low Level, (Mid-Level) *


High Level -  using compiler/interpreter 
Assembly Level - assembler
- Machine (binary) 0 1

Compiler : 
	Take all inst. at once -> check 
	
	code - source file
	save
	compile	
		-object   ./a.out 	-> exe
		-bytecode (JIT - Just InTime COmpilation) 
		
	ek bar check	- comipile time
	jitne bar run
	run

Interpreter : 
	Line by line exe. -> run 
	har bar run -> har bar check -> runtime


- Basics of Binary * (Decimal representation, basics of conversion)

swicth on ya off 
decimal - 0,1,2,3,4,5,6,7,8,9 = 

3145 = 
	3*1000 +  0 * 100  + 4*10 + 5*1
		
	10^3          10^2	10^1	10^0

	base=10

binary- 0,1 	

0 - 0
1 - 1
2 - 10
3 -  11
4-  100

    01 - 1
+  01 - 1
    10 - 2

bitwise (binary)
	


3*1000 +  0 * 100  + 4*10 + 5*1
3 = 1 * 2^1 + 1 * 2^0	
	

3 = 2 +1
base 2

345 binary 
highest of two

1 0 1 1 1	binary to decimal
1+2+4+0+16+ = 23
		
64+0+16+0+4+2+1 = decimal

4/2 rem 0
2/2 rem 0
1
100

25 / 2  rem 1
12 /2   rem 0
6/2     rem 0
3/2  rem 1
1

11001

16+8+1 = 25

octal base8  
hexadecimal base16   0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F	

Binary

and	
	1 &  1 = 1
	1 & 0 = 0
	0 & 1 = 0
	0 & 0 = 0
or	
	1 |  1 = 1
	1 | 0 = 1
	0 | 1 = 1
	0 | 0 = 0
 	
xor ^  not same
	1 ^ 1  = 0
	0 ^ 0  = 0
	1 ^ 0  = 1
 	0 ^ 1  = 1
	
5 - 101
4 - 100
xor - 001
or - 101 - 5
and - 100 - 4


not ~  negation Flips the bits  8bit lo,,, fir represent kro  int - 4byte - 16 bit 
3 - 00000011

5 = 000001 0 1
	     1
	11 0

taking negation  =  11111010		MSB 0 - Positive  MSB 1 - Negative
Since MSB is 1 so the no. is going to be negative
now 					 - 11111010
1's Complement 			   =   	 - 00000101 
2's Complement (add 1 to 1's complement) = 	 - 00000110  -> -6  ans.


so negation of 5 is -6

	
4 = 100
 
and 100 = 4
 or 101 = 5


bitwise


	- Compiler, Interpreter, Assembler *
	- Phases of program building*

C C++ Java C#	
		Python
	- Python Features (Pros & Cons, Comaparsion with other lang)
		- development speed	
		- execution speed		
		- code elegance
		- type safety
		- data types
		- low control


Functional - function oriented

Object Oriented - 
	Inheritance	
	polymorphism 
	encapsulation(hiding)
	
	abstract




keyword
list
vector<int,n>(0) a;

arrays [0 1  4  0  1  0  1  0  1]   position change by 1

access arr[2]
O(1)
deletion
insertion

list (linked list) [0 0 1 1 2 2 0 1]
O(n)
O(1)
1->4->2->3


arrays & list python same




	**************************************************************
Python Begins
	- Interpreter
	- Basics (Numbers, Strings, Lists)
	- Data Types(Integers, Floating Point, Complex, Strings Boolean,
	


+ - * / 
** exp
% rem
// int division

bitwise 
and &
or |
xor ^
negation ~
left shift <<  
right shift >>


2 = 

1000
2^3 = 8

2^5 = 32










